Clase MovimientoDeAtaque:
   Cumple con el SRP porque tiene una sola tarea: representar un ataque en el juego. 
   Es un experto en su información, ya que maneja todo lo necesario para un movimiento 
   de ataque (como el daño, el tipo, si es especial o si ya fue usado). 
   Usa polimorfismo al implementar la interfaz IMovimiento_Ataque, lo que le permite 
   ser utilizada de manera flexible en otras partes del código. 
   Además, sigue el LSP, ya que se puede usar en lugar de cualquier otra clase que 
   implemente la misma interfaz sin causar problemas.

Clase MovimientoDeDefensa:
   Cumple con el SRP porque tiene una sola tarea: representar un movimiento de defensa 
   en el juego. 
   Es un experto en su información, ya que maneja todo lo necesario para un movimiento 
   de defensa (como el valor de defensa, el tipo, si es especial o si ya fue usado). 
   Usa polimorfismo al implementar la interfaz IMovimiento_Defensa, lo que le permite 
   ser utilizada de manera flexible en otras partes del código. 
   Además, sigue el LSP, ya que se puede usar en lugar de cualquier otra clase que 
   implemente la misma interfaz sin causar problemas.

Clase MovimientoDeAtaqueDefensa:
   La clase MovimientoDeAtaqueDefensa sigue el SRP al enfocarse solo en representar un 
   movimiento de ataque y defensa. Cumple con el principio Expert porque maneja la lógica 
   de sus atributos como ataque, defensa y tipo. Utiliza polimorfismo al implementar dos 
   interfaces, permitiendo que se use tanto como movimiento de ataque o de defensa. 
   Sigue el principio de Liskov (LSP) porque puede sustituir a otras clases que 
   implementan estas interfaces sin problemas.

Clase Pokemon:
   Sigue el principio SRP al encargarse solo de gestionar atributos como vida, defensa, 
   movimientos y acciones de ataque y defensa. También aplica el principio Expert, ya que 
   maneja su lógica propia 
   al ejecutar los movimientos de los Pokemones, como defenderse o recibir ataques.
   El polimorfismo se muestra en el uso de las interfaces IMovimiento_Ataque y IMovimiento_Defensa, 
   haciendo que diferentes tipos de movimientos interactúen con el mismo Pokémon. 
   Respeta el principio LSP porque los objetos que implementan estas interfaces pueden usarse de manera 
   intercambiable sin romper el funcionamiento.

Clase Pokedex:
   Cumple con el princpio de SRP, ya que se encarga de crear todos los pokemones con sus tipos,
   efectividades y movimientos característicos.
   Cumple con Expert porque tiene toda la informacion necesaria para sus tareas en sí misma.
   Cumple con Creator ya que se encarga de crear instancias de la clase Pokemon.

Clase Batalla:
   La clase Batalla cumple con el principio de Responsabilidad Única (SRP) porque se encarga 
   exclusivamente de la lógica relacionada con el manejo de una batalla entre dos jugadores. 
   Esto incluye iniciar y terminar la batalla, avanzar los turnos, y determinar el estado de 
   la batalla (si ha terminado o no). Esto hace que también cumpla con Expert al gestionar 
   únicamente la lógica de la batalla y ser experta en ello.

Clase Jugador:
   SRP se aplica al gestionar la información del jugador, aunque algunas responsabilidades, 
   como la actualización del estado del equipo, pueden complicar su enfoque. Expert Principle 
   está presente, ya que la clase maneja sus propios datos y toma decisiones basadas en ellos.

Clase Menu:
  La clase Menu cumple con el Principio de Responsabilidad Única (SRP) al gestionar exclusivamente 
  las interacciones del menú para la batalla de Pokémon, y en el Principio de Abierto/Cerrado (OCP), 
  ya que permite la extensión sin modificar la funcionalidad existente. Además, sigue el Principio de 
  Inversión de Dependencias (DIP) al depender de abstracciones como Jugador e IMovimiento, y el Principio 
  de Sustitución de Liskov (LSP) al permitir el uso de diferentes implementaciones de IMovimiento.

Clase Tipos:
   Se adhiere al Principio de Responsabilidad Única (SRP) al gestionar exclusivamente las efectividades 
   entre tipos. El Principio de Sustitución de Liskov (LSP) se cumple al permitir que futuras subclases 
   se comporten como instancias de Tipo.